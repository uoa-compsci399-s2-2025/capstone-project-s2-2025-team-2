import FirestoreCollections from "../adapters/FirestoreCollections"
import { Reagent, ReagentCategory } from "../../business-layer/models/Reagent"
import { FieldValue } from "firebase-admin/firestore";
import { daysUntilExpiry } from "../../utils/dateCalculate"

export class ReagentService {
  /**
   * Retrieves all reagents from the Firestore database.
   *
   * @returns Promise<Reagent[]> - Returns an array of all reagents.
   */
  async getAllReagents(): Promise<Reagent[]> {
    const reagentsSnapshot = await FirestoreCollections.reagents.get()
    return reagentsSnapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() }))
  }

  /**
   * Retrieves a reagent by its ID from the Firestore database.
   *
   * @param id - The ID of the reagent to retrieve.
   * @returns Promise<Reagent | null> - Returns the reagent if found, otherwise null.
   */
  async getReagentById(id: string): Promise<Reagent | null> {
    const reagentSnapshot = await FirestoreCollections.reagents.doc(id).get()
    if (!reagentSnapshot.exists) {
      return null
    }
    return reagentSnapshot.data()
  }

  async getAllReagentsRaw() {
    return FirestoreCollections.reagents.get()
  }

  /**
   * Retrieves reagents by its categories from the Firestore database.
   *
   * @param categories - The category of the reagents to retrive.
   * @returns Promise<Reagent[]> - Returns an array of reagents.
   */
  async getReagentsByCategory(
    categories: ReagentCategory[],
  ): Promise<Reagent[]> {
    const reagentsSnapshot = await FirestoreCollections.reagents
      .where("categories", "array-contains-any", categories)
      .get()
    return reagentsSnapshot.docs.map((doc) => doc.data())
  }

  /**
   * Creates a new reagent in the Firestore database.
   *
   * @param newReagent - The new reagent to create.
   * @returns Reagent - Returns the created reagent with its ID generated by firebase
   */

async createReagent(newReagent: Reagent): Promise<Reagent> {
  const now = new Date();
  const nzDate = new Date(
    now.toLocaleString("en-US", { timeZone: "Pacific/Auckland" })
  );

  const year = nzDate.getFullYear();
  const month = String(nzDate.getMonth() + 1).padStart(2, "0");
  const day = String(nzDate.getDate()).padStart(2, "0");
  const formattedCreatedAt = `${year}-${month}-${day}`;

  const docRef = await FirestoreCollections.reagents.add({
    ...newReagent,
    createdAt: FieldValue.serverTimestamp(),
    createdAtReadable: formattedCreatedAt, 
  });

  const docSnap = await docRef.get();
  return { id: docRef.id, ...docSnap.data() } as Reagent;
}



  /**
   * Deletes a reagent from the Firestore database.
   *
   * @param id - The ID of the reagent to delete.
   * @returns Reagent - Returns the deleted reagent as a ref.
   */
  async deleteReagent(id: string): Promise<Reagent> {
    try {
      const docRef = await FirestoreCollections.reagents.doc(id)
      if (docRef == null) {
        throw new Error(`Reagent - ${id} not found`)
      }
      const reagent = (await docRef.get()).data() as Reagent
      await docRef.delete()
      return reagent
    } catch (err) {
      console.log(err)
      throw new Error(`Failed to delete reagent - ${id}: ${err}`)
    }
  }

  /**
   * updates a reagent in the Firestore database.
   *
   * @param id - The ID of the reagent to update.
   * @param update - The update to apply to the reagent.
   * @returns Reagent - Returns the updated reagent.
   */
  async updateReagent(id: string, update: Partial<Reagent>): Promise<Reagent> {
    try {
      const docRef = await FirestoreCollections.reagents.doc(id)
      const snapShot = await docRef.get()
      if (!snapShot.exists) {
        throw new Error(`Reagent - ${id} not found`)
      }
      const { user_id, ...SafeUpdate } = update
      console.log(`User updating reagent- ${id}`, user_id)
      await docRef.update(SafeUpdate)
      const updatedDoc = await docRef.get()
      return updatedDoc.data() as Reagent
    } catch (err) {
      console.log(err)
      throw new Error(`Failed to update reagent - ${id}: ${err}`)
    }
  }

  /**
   * Retrieves reagents by its owner from the Firestore database.
   *
   * @param user_id - The user id used to get its reagents.
   * @returns Promise<Reagent[]> - Returns an array of reagents.
   */
  async getReagentsByUserId(user_id: string): Promise<Reagent[]> {
    const reagentsSnapshot = await FirestoreCollections.reagents
      .where("user_id", "==", user_id)
      .get()
    return reagentsSnapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() }))
  }

  /**
   * Retrieves reagents expiring in 60 days or less for a certain user.
   *
   * @returns Promise<Reagent[]> - Returns an array of reagents.
   */
  async getReagentsExpiringSoon(user_id: string): Promise<Reagent[]> {
    try {
      const reagentsSnapshot = await FirestoreCollections.reagents
        .where("user_id", "==", user_id)
        .get()
      const reagents = reagentsSnapshot.docs.map((doc) => doc.data())
      return reagents.filter((reagent) => {
        if (!reagent.expiryDate) return false
        const daysLeft = daysUntilExpiry(reagent.expiryDate)
        return daysLeft <= 60 && daysLeft >= 0
      })
    } catch (err) {
      console.log(err)
      throw new Error(`Failed to get reagents expiring soon: ${err}`)
    }
  }

  /**
   * Retrieves reagents expiring in exactly 30 days for all users, grouped by their user ID.
   *
   * @returns Promise<Record<string, Reagent[]>> - Returns a dictionary with userID as key and array of reagents as value.
   *
   */
  async getReagentsExpiringSoonAllUsers(): Promise<Record<string, Reagent[]>> {
    try {
      const reagentsSnapshot = await FirestoreCollections.reagents.get()
      const reagents = reagentsSnapshot.docs.map((doc) => doc.data())

      const expiringReagents = reagents.filter((reagent) => {
        if (!reagent.expiryDate) return false
        const daysLeft = daysUntilExpiry(reagent.expiryDate)
        return daysLeft == 29
      })

      const groupedReagents: Record<string, Reagent[]> = {}

      expiringReagents.forEach((reagent) => {
        const userId = reagent.user_id
        if (!groupedReagents[userId]) {
          groupedReagents[userId] = []
        }
        groupedReagents[userId].push(reagent)
      })

      return groupedReagents
    } catch (err) {
      console.log(err)
      throw new Error(
        `Failed to get reagents expiring soon for all users: ${err}`,
      )
    }
  }
}
