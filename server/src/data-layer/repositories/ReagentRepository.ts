import FirestoreCollections from "../adapters/FirestoreCollections"
import { Reagent, ReagentCategory } from "../../business-layer/models/Reagent"
export class ReagentService {
  /**
   * Retrieves all reagents from the Firestore database.
   *
   * @returns Promise<Reagent[]> - Returns an array of all reagents.
   */
  async getAllReagents(): Promise<Reagent[]> {
    const reagentsSnapshot = await FirestoreCollections.reagents.get()
    return reagentsSnapshot.docs.map((doc) => ({
      id: doc.id,
      ...(doc.data() as Omit<Reagent, "id">),
    }))
  }

  /**
   * Retrieves a reagent by its ID from the Firestore database.
   *
   * @param id - The ID of the reagent to retrieve.
   * @returns Promise<Reagent | null> - Returns the reagent if found, otherwise null.
   */
  async getReagentById(id: string): Promise<Reagent | null> {
    const reagentSnapshot = await FirestoreCollections.reagents.doc(id).get()
    if (!reagentSnapshot.exists) {
      return null
    }
    return reagentSnapshot.data()
  }

  async getAllReagentsRaw() {
    return FirestoreCollections.reagents.get()
  }

  /**
   * Retrieves reagents by its categories from the Firestore database.
   *
   * @param categories - The category of the reagents to retrive.
   * @returns Promise<Reagent[]> - Returns an array of reagents.
   */
  async getReagentsByCategory(
    categories: ReagentCategory[],
  ): Promise<Reagent[]> {
    const reagentsSnapshot = await FirestoreCollections.reagents
      .where("categories", "array-contains-any", categories)
      .get()
    return reagentsSnapshot.docs.map((doc) => doc.data())
  }

  /**
   * Creates a new reagent in the Firestore database.
   *
   * @param newReagent - The new reagent to create.
   * @returns Reagent - Returns the created reagent with its ID generated by firebase
   */
  async createReagent(newReagent: Reagent): Promise<Reagent> {
    const now = new Date()
    // Add createdAt timestamp
    const docRef = await FirestoreCollections.reagents.add({
      ...newReagent,
      createdAt: now,
    })

    const createdReagent = {
      ...newReagent,
      id: docRef.id,
      createdAt: now,
    }

    return createdReagent
  }

  /**
   * Deletes a reagent from the Firestore database.
   *
   * @param id - The ID of the reagent to delete.
   * @returns Reagent - Returns the deleted reagent as a ref.
   */
  async deleteReagent(id: string): Promise<Reagent> {
    try {
      const docRef = await FirestoreCollections.reagents.doc(id)
      if (docRef == null) {
        throw new Error(`Reagent - ${id} not found`)
      }
      const reagent = (await docRef.get()).data() as Reagent
      await docRef.delete()
      return reagent
    } catch (err) {
      console.log(err)
      throw new Error(`Failed to delete reagent - ${id}: ${err}`)
    }
  }

  /**
   * updates a reagent in the Firestore database.
   *
   * @param id - The ID of the reagent to update.
   * @param update - The update to apply to the reagent.
   * @returns Reagent - Returns the updated reagent.
   */
  async updateReagent(id: string, update: Partial<Reagent>): Promise<Reagent> {
    try {
      const docRef = await FirestoreCollections.reagents.doc(id)
      const snapShot = await docRef.get()
      if (!snapShot.exists) {
        throw new Error(`Reagent - ${id} not found`)
      }
      const { user_id, ...SafeUpdate } = update
      console.log(`User updating reagent- ${id}`, user_id)
      await docRef.update(SafeUpdate)
      const updatedDoc = await docRef.get()
      return updatedDoc.data() as Reagent
    } catch (err) {
      console.log(err)
      throw new Error(`Failed to update reagent - ${id}: ${err}`)
    }
  }

  /**
   * Retrieves reagents by its owner from the Firestore database.
   *
   * @param user_id - The user id used to get its reagents.
   * @returns Promise<Reagent[]> - Returns an array of reagents.
   */
  async getReagentsByUserId(user_id: string): Promise<Reagent[]> {
    const reagentsSnapshot = await FirestoreCollections.reagents
      .where("user_id", "==", user_id)
      .get()
    return reagentsSnapshot.docs.map((doc) => doc.data())
  }
}
