import FirestoreCollections from "../adapters/FirestoreCollections"
import { Reagent, ReagentCategory } from "../../business-layer/models/Reagent"
import { daysUntilExpiry } from "../../utils/dateCalculate"
import { Timestamp } from "firebase-admin/firestore"

export class ReagentService {
  /**
   * Retrieves all reagents or wanted reagents from the Firestore database.
   *
   * @returns Promise<Reagent[]> - Returns an array of all reagents.
   */
  async getAllReagents(
    type: "reagents" | "wanted" = "reagents",
  ): Promise<Reagent[]> {
    const collection =
      type === "wanted"
        ? FirestoreCollections.wanted
        : FirestoreCollections.reagents
    const reagentsSnapshot = await collection.get()

    return reagentsSnapshot.docs.map((doc) => {
      const data = doc.data()
      return { id: doc.id, ...data } as Reagent
    })
  }

  /**
   * Retrieves a reagent/wanted reagent by its ID from the Firestore database.
   *
   * @param id - The ID of the reagent to retrieve.
   * @returns Promise<Reagent | null> - Returns the reagent if found, otherwise null.
   */
  async getReagentById(
    id: string,
    type: "reagents" | "wanted" = "reagents",
  ): Promise<Reagent | null> {
    const collection =
      type === "wanted"
        ? FirestoreCollections.wanted
        : FirestoreCollections.reagents
    const reagentSnapshot = await collection.doc(id).get()
    if (!reagentSnapshot.exists) {
      return null
    }
    return reagentSnapshot.data()
  }

  async getAllReagentsRaw() {
    return FirestoreCollections.reagents.get()
  }

  /**
   * Retrieves reagents/wanted reagent by its categories from the Firestore database.
   *
   * @param categories - The category of the reagents to retrive.
   * @returns Promise<Reagent[]> - Returns an array of reagents.
   */
  async getReagentsByCategory(
    categories: ReagentCategory[],
    type: "reagents" | "wanted" = "reagents",
  ): Promise<Reagent[]> {
    const collection =
      type === "wanted"
        ? FirestoreCollections.wanted
        : FirestoreCollections.reagents
    const reagentsSnapshot = await collection
      .where("categories", "array-contains-any", categories)
      .get()
    return reagentsSnapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() }))
  }

  /**
   * Creates a new reagent/wanted reagent in the Firestore database.
   *
   * @param newReagent - The new reagent to create.
   * @returns Reagent - Returns the created reagent with its ID generated by firebase
   */

  async createReagent(
    newReagent: Omit<Reagent, "createdAt" | "createdAtReadable" | "id">,
    type: "reagents" | "wanted" = "reagents",
  ): Promise<Reagent & { id: string }> {
    const collection =
      type === "wanted"
        ? FirestoreCollections.wanted
        : FirestoreCollections.reagents
    const createdAt = Timestamp.now().toDate().toISOString()
    const createdAtReadable = new Date().toISOString().split("T")[0]

    const docRef = await collection.add({
      ...newReagent,
      createdAt,
      createdAtReadable,
    })

    const result = {
      ...newReagent,
      id: docRef.id,
      createdAt,
      createdAtReadable,
    }
    return result
  }

  /**
   * Deletes a reagent from the Firestore database.
   *
   * @param id - The ID of the reagent to delete.
   * @returns Reagent - Returns the deleted reagent as a ref.
   */
  async deleteReagent(id: string): Promise<Reagent> {
    try {
      const docRef = await FirestoreCollections.reagents.doc(id)
      if (docRef == null) {
        throw new Error(`Reagent - ${id} not found`)
      }
      const reagent = (await docRef.get()).data() as Reagent
      await docRef.delete()
      return reagent
    } catch (err) {
      console.log(err)
      throw new Error(`Failed to delete reagent - ${id}: ${err}`)
    }
  }

  /**
   * updates a reagent in the Firestore database.
   *
   * @param id - The ID of the reagent to update.
   * @param update - The update to apply to the reagent.
   * @returns Reagent - Returns the updated reagent.
   */
  async updateReagent(id: string, update: Partial<Reagent>): Promise<Reagent> {
    try {
      const docRef = await FirestoreCollections.reagents.doc(id)
      const snapShot = await docRef.get()
      if (!snapShot.exists) {
        throw new Error(`Reagent - ${id} not found`)
      }
      const { user_id, ...SafeUpdate } = update
      console.log(`User updating reagent- ${id}`, user_id)
      await docRef.update(SafeUpdate)
      const updatedDoc = await docRef.get()
      return updatedDoc.data() as Reagent
    } catch (err) {
      console.log(err)
      throw new Error(`Failed to update reagent - ${id}: ${err}`)
    }
  }

  /**
   * Retrieves reagents by its owner from the Firestore database.
   *
   * @param user_id - The user id used to get its reagents.
   * @returns Promise<Reagent[]> - Returns an array of reagents.
   */
  async getReagentsByUserId(
    user_id: string,
    type: "reagents" | "wanted" = "reagents",
  ): Promise<Reagent[]> {
    const collection =
      type === "wanted"
        ? FirestoreCollections.wanted
        : FirestoreCollections.reagents
    const reagentsSnapshot = await collection
      .where("user_id", "==", user_id)
      .get()
    return reagentsSnapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() }))
  }

  /**
   * Retrieves reagents expiring in 60 days or less for a certain user.
   *
   * @returns Promise<Reagent[]> - Returns an array of reagents.
   */
  async getReagentsExpiringSoon(user_id: string): Promise<Reagent[]> {
    try {
      const reagentsSnapshot = await FirestoreCollections.reagents
        .where("user_id", "==", user_id)
        .get()
      const reagents = reagentsSnapshot.docs.map((doc) => doc.data())
      return reagents.filter((reagent) => {
        if (!reagent.expiryDate) return false
        const daysLeft = daysUntilExpiry(reagent.expiryDate)
        return daysLeft <= 60 && daysLeft >= 0
      })
    } catch (err) {
      console.log(err)
      throw new Error(`Failed to get reagents expiring soon: ${err}`)
    }
  }

  /**
   * Retrieves reagents expiring in exactly 30 days for all users, grouped by their user ID.
   *
   * @returns Promise<Record<string, Reagent[]>> - Returns a dictionary with userID as key and array of reagents as value.
   *
   */
  async getReagentsExpiringSoonAllUsers(): Promise<Record<string, Reagent[]>> {
    try {
      const reagentsSnapshot = await FirestoreCollections.reagents.get()
      const reagents = reagentsSnapshot.docs.map((doc) => doc.data())

      const expiringReagents = reagents.filter((reagent) => {
        if (!reagent.expiryDate) return false
        const daysLeft = daysUntilExpiry(reagent.expiryDate)
        return daysLeft == 29
      })

      const groupedReagents: Record<string, Reagent[]> = {}

      expiringReagents.forEach((reagent) => {
        const userId = reagent.user_id
        if (!groupedReagents[userId]) {
          groupedReagents[userId] = []
        }
        groupedReagents[userId].push(reagent)
      })

      return groupedReagents
    } catch (err) {
      console.log(err)
      throw new Error(
        `Failed to get reagents expiring soon for all users: ${err}`,
      )
    }
  }
}
